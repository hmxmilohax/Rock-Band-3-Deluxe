{func
   dx_overshell_msg
   ($message)
   ;opens player message panel on current player
   {if {! {session is_in_game}}
      {{overshell_player_message find show.trg} trigger}
      {overshell_player_message set_showing TRUE}
      {set $dx_no_message_sound TRUE} ;prevents message sound from playing in menus
      ($this setup_message_text $message)
   }
}
{func
   dx_check_for_dupe ; function to allow 5L/Pro instruments together but still block same parts from being selected
   ($slot) ; current slot number of the user
   {do
      {set $selected_part ; grabs the currently selected part of the user
         {switch $slot
            (0 $default_slot0)
            (1 $default_slot1)
            (2 $default_slot2)
            (3 $default_slot3)
         }
      }
      (set $dupe_allowed TRUE) ; allows dupe TRUE by default, any check below will set it to FALSE
      {switch $selected_part
         ((overshell_drums overshell_drums_pro)
            {user_mgr foreach_user $user
               {unless {== {$user get_slot_num} $slot} ; don't compare user against themself
                  {if {== {$user get_track_type} kTrackDrum} {set $dupe_allowed FALSE}} ; block dupe if another player already has this part
               }
            }
         )
         (overshell_guitar
            {user_mgr foreach_user $user
               {unless {== {$user get_slot_num} $slot} ; don't compare user against themself
                  {if {== {$user get_track_type} kTrackGuitar} {set $dupe_allowed FALSE}} ; block dupe if another player already has this part
               }
            }
         )
         (overshell_real_guitar
            {user_mgr foreach_user $user
               {unless {== {$user get_slot_num} $slot} ; don't compare user against themself
                  {if {== {$user get_track_type} kTrackRealGuitar} {set $dupe_allowed FALSE}} ; block dupe if another player already has this part
               }
            }
         )
         (overshell_bass
            {user_mgr foreach_user $user
               {unless {== {$user get_slot_num} $slot} ; don't compare user against themself
                  {if {== {$user get_track_type} kTrackBass} {set $dupe_allowed FALSE}} ; block dupe if another player already has this part
               }
            }
         )
         (overshell_real_bass
            {user_mgr foreach_user $user
               {unless {== {$user get_slot_num} $slot} ; don't compare user against themself
                  {if {== {$user get_track_type} kTrackRealBass} {set $dupe_allowed FALSE}} ; block dupe if another player already has this part
               }
            }
         )
         (overshell_keys
            {user_mgr foreach_user $user
               {unless {== {$user get_slot_num} $slot} ; don't compare user against themself
                  {if {== {$user get_track_type} kTrackKeys} {set $dupe_allowed FALSE}} ; block dupe if another player already has this part
               }
            }
         )
         (overshell_real_keys
            {user_mgr foreach_user $user
               {unless {== {$user get_slot_num} $slot} ; don't compare user against themself
                  {if {== {$user get_track_type} kTrackRealKeys} {set $dupe_allowed FALSE}} ; block dupe if another player already has this part
               }
            }
         )
      }
      $dupe_allowed ; returns dupe TRUE/FALSE check back to slot_states
   }
}
{func
   dx_state_setup
   ($current_overshell_state $message)
   {unless $in_state ;the view code trick runs several times, so we need to make sure to only run the function once in the view
      {set $in_state TRUE} ;gate it off REMEMBER, turn this to false when running this code in a reset handle
      {overshell_list_creation}
      {overshell_list_chooser}
      {$current_list set circular $options_circular}
      {$current_list set_data $options_list_data}
      {set $previous_state $current_state} ;don't rely on this this is only useful for a big switch state with many entry points, aka texture states
      {set $current_state $current_overshell_state}
      {foreach $entry $dx_state_tracker
         {if {== {elem $entry 0} {basename $current_overshell_state}}
            {$current_list set_selected {elem {find $entry {sprint $current_overshell_state}} 1}}
         }
      }
      ;{if $message
      ;   {dx_overshell_msg $message}
      ;}
      {set $dx_tracked_changed FALSE}
      #ifdef HX_WII {choose_profile.lbl set text_token os_blnk} #endif
   }
}
{func
   dx_state_pos_tracker
   {set $in_state FALSE}
   {if_else $dx_tracked_changed
      {set $current_state_pos $dx_tracked_changed} ;probe the item we will be switching too
      {set $current_state_pos {$current_list selected_sym}} ;probe the current list position
   }
   {unless $dx_tracked_changed
      ;clean up the list for the state transition
      {switch $current_slots
         (1 {$current_list set_data (os_blnk)})
         (2 {$current_list set_data (os_blnk os_blnk)})
         (3 {$current_list set_data (os_blnk os_blnk os_blnk)})
         (4 {$current_list set_data (os_blnk os_blnk os_blnk os_blnk)})
         (5 {$current_list set_data (os_blnk os_blnk os_blnk os_blnk os_blnk)})
         (6 {$current_list set_data (os_blnk os_blnk os_blnk os_blnk os_blnk os_blnk)})
         (7 {$current_list set_data (os_blnk os_blnk os_blnk os_blnk os_blnk os_blnk os_blnk)})
      }
   }
   ;this is stupid but it works
   {foreach $entry $dx_state_tracker
      {if {== {elem $entry 0} {basename $current_state}} ;first check if we have the state tracked already
         {remove_elem {find $dx_state_tracker $current_state} {elem {find $dx_state_tracker $current_state} 1}} ;removed the previously tracked list position
         {push_back {find $dx_state_tracker $current_state} $current_state_pos} ;add in the new list position
      }
   }

   {foreach $entry $dx_state_tracker
      {if {!= {elem $entry 0} {basename $current_state}} ;check if the state isnt in the list
         {set $pushtime_guitar TRUE} ;get ready to push it
      }
   }
   {foreach $entry $dx_state_tracker
      {if {== {elem $entry 0} {basename $current_state}} ;check the list again, and if it is in the list
         {set $pushtime_guitar FALSE} ;dont push it
      }
   }
   {if $pushtime_guitar ;if we need to push
      {push_back $dx_state_tracker ($current_state $current_state_pos)} ;push_back a new state into the array
   }

   {foreach $entry $dx_state_tracker
      {if {!= {elem $entry 0} {basename $current_state}} ;check if the state isnt in the list
         {set $pushtime_drum TRUE} ;get ready to push it
      }
   }
   {foreach $entry $dx_state_tracker
      {if {== {elem $entry 0} {basename $current_state}} ;check the list again, and if it is in the list
         {set $pushtime_drum FALSE} ;dont push it
      }
   }
   {if $pushtime_drum ;if we need to push
      {push_back $dx_state_tracker ($current_state $current_state_pos)} ;push_back a new state into the array
   }
   
   {foreach $entry $dx_state_tracker
      {if {!= {elem $entry 0} {basename $current_state}} ;check if the state isnt in the list
         {set $pushtime_bass TRUE} ;get ready to push it
      }
   }
   {foreach $entry $dx_state_tracker
      {if {== {elem $entry 0} {basename $current_state}} ;check the list again, and if it is in the list
         {set $pushtime_bass FALSE} ;dont push it
      }
   }
   {if $pushtime_bass ;if we need to push
      {push_back $dx_state_tracker ($current_state $current_state_pos)} ;push_back a new state into the array
   }
   
   {foreach $entry $dx_state_tracker
      {if {!= {elem $entry 0} {basename $current_state}} ;check if the state isnt in the list
         {set $pushtime_keys TRUE} ;get ready to push it
      }
   }
   {foreach $entry $dx_state_tracker
      {if {== {elem $entry 0} {basename $current_state}} ;check the list again, and if it is in the list
         {set $pushtime_keys FALSE} ;dont push it
      }
   }
   {if $pushtime_keys ;if we need to push
      {push_back $dx_state_tracker ($current_state $current_state_pos)} ;push_back a new state into the array
   }

   {set $dx_state_tracker {array $dx_state_tracker}} ;re read the array so the vars enumerate and the array becomes static
   {$current_list set circular FALSE}
   {set $in_state FALSE}
   ;{dx_log_writer TRUE {array $dx_state_tracker}}
}
{func
   overshell_list_chooser
   {switch $current_slots
      (1 {do {set $current_list confirm_action.lst}})
      (2 {do {set $current_list options_end_game.lst}})
      (3 {do {set $current_list options_extras.lst}})
      (4 {do {set $current_list #ifdef HX_WII online_options.lst #else online_options.lst #endif}})
      (5 {do {set $current_list #ifdef HX_WII options_audio.lst #else options.lst #endif}})
      (6 {do {set $current_list #ifdef HX_WII profiles_wii.lst #else options_audio.lst #endif}})
      (7 {do {set $current_list game_options.lst}})
   }
   {$current_list set circular $options_circular}
   {$current_list set display_num $current_slots}
   {$current_list set max_display $current_slots}
   {$current_list set scroll_past_max_display FALSE}
   {$current_list set scroll_time 0}
   {$current_list set_data $options_list_data}
}
{func
   overshell_view_chooser
   {switch $current_slots
      (1 confirm_action)
      (2 options_end_game)
      (3 options_extras)
      (4 #ifdef HX_WII online_options #else online_options #endif)
      (5 #ifdef HX_WII options_audio #else options #endif)
      (6 #ifdef HX_WII choose_profile_wii #else options_audio #endif)
      (7 game_options)
   }
}
{func
   overshell_list_creation
   {$this iterate CheckboxDisplay $c {$c set checked FALSE}}
   {set $num_of_slots 0}
   {foreach $entry $options
      {set $num_of_slots {+ $num_of_slots 1}}
   }
   {if_else {>= $num_of_slots 9}
      {set $options_circular TRUE}
      {set $options_circular FALSE}
   }
   {if {>= $num_of_slots 6}
      {set $num_of_slots 6}
   }
   {set $current_slots $num_of_slots}
   {unless {$this in_game} ;in game overshell does not need to account for same slot size animation transitions
      {if {== $current_slots $previous_num_slot}
         {if_else {< $current_slots 6}
            {set $num_of_slots {+ $num_of_slots 1}}
            {set $num_of_slots {- $num_of_slots 1}}
         }
      }
      {set $previous_num_slot $num_of_slots}
      {set $current_slots $num_of_slots}
   }
   $options
   {set $options_list_data {array $options}}
}
