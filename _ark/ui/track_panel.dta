#define TRACK_END_FRAME
(1920)
(new Object fc_guitar_callback ;remove FC groove on guitar miss/pass
   (hit
      {if {! $guitar_firstnote} {set $guitar_firstnote TRUE}}
     {if {! $guitar_milosong} {set $guitar_milosong TRUE} {set [num_gems_hit] 0} {set [num_gems_miss] 0} {set [num_gems_pass] 0} {set [num_gems_combo] 0}}
      {$this check_fc}
      {set [num_gems_hit] {'+' [num_gems_hit] 1}}
      {set [num_gems_combo] {'+' [num_gems_combo] 1}}
      {if {modifier_mgr is_modifier_active mod_fastermode}
         {unless {>= $speedmod $speedmod_cap}
            {set $speedmod {+ $speedmod 0.002}}
            {beatmatch set_music_speed $speedmod}
            {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
            {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
            {{{gamemode get track_panel} find mtv_overlay} setup_text}
            {if {> $speedmod $speedmod_top}
               {set $speedmod_top $speedmod}
            }
         }
      }
   )
   (miss
      {unless {! $guitar_firstnote}
         {set [num_gems_miss] {'+' [num_gems_miss] 1}}
         {set [num_gems_combo] 0}
         {$this check_missed}
         {if {! $guitar_caughtmissed}
            {set $guitar_caughtmissed TRUE}
            {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
         }
         {if {modifier_mgr is_modifier_active mod_fastermode}
            {unless {<= $speedmod $leaderspeed}
               {set $speedmod {- $speedmod 0.004}}
               {beatmatch set_music_speed $speedmod}
               {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
               {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
               {{{gamemode get track_panel} find mtv_overlay} setup_text}
            }
         }
      }
   )
   (pass
      {if {! $guitar_firstnote} {set $guitar_firstnote TRUE}}
      {if {! $guitar_milosong} {set $guitar_milosong TRUE} {set [num_gems_hit] 1} {set [num_gems_miss] 1} {set [num_gems_pass] 1} {set [num_gems_combo] 1}}
      {set [num_gems_pass] {'+' [num_gems_pass] 1}}
      {set [num_gems_combo] 0}
      {$this check_missed}
      {if {! $guitar_caughtmissed}
         {set $guitar_caughtmissed TRUE}
         {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
      }
      {if {modifier_mgr is_modifier_active mod_fastermode}
         {unless {<= $speedmod $leaderspeed}
            {set $speedmod {- $speedmod 0.004}}
            {beatmatch set_music_speed $speedmod}
            {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
            {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
            {{{gamemode get track_panel} find mtv_overlay} setup_text}
         }
      }
   )
   (check_fc
      {$this check_missed}
      {if {== {'+' [num_gems_pass] [num_gems_miss]} 0}
         {set $fc TRUE}
      }
   )
   (check_missed
      {if {> {'+' [num_gems_miss] [num_gems_pass]} 0}
         {if {! $guitar_caughtmissed}
            {set $guitar_caughtmissed TRUE}
            {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
         }
      }
   )
   (num_gems_hit 0)
   (num_gems_combo 0)
   (num_gems_miss 0)
   (num_gems_pass 0)
)
(new Object fc_real_guitar_callback ;remove FC groove on real_guitar miss/pass
   (hit
      {if {! $real_guitar_firstnote} {set $real_guitar_firstnote TRUE}}
      {if {! $real_guitar_milosong} {set $real_guitar_milosong TRUE} {set [num_gems_hit] 0} {set [num_gems_miss] 0} {set [num_gems_pass] 0} {set [num_gems_combo] 0}}
      {$this check_fc}
      {set [num_gems_hit] {'+' [num_gems_hit] 1}}
      {set [num_gems_combo] {'+' [num_gems_combo] 1}}
      {if {modifier_mgr is_modifier_active mod_fastermode}
         {unless {>= $speedmod $speedmod_cap}
            {set $speedmod {+ $speedmod 0.002}}
            {beatmatch set_music_speed $speedmod}
            {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
            {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
            {{{gamemode get track_panel} find mtv_overlay} setup_text}
            {if {> $speedmod $speedmod_top}
               {set $speedmod_top $speedmod}
            }
         }
      }
     )
   (miss
      {unless {! $real_guitar_firstnote}
         {set [num_gems_miss] {'+' [num_gems_miss] 1}}
         {set [num_gems_combo] 0}
         {$this check_missed}
         {if {! $real_guitar_caughtmissed}
            {set $real_guitar_caughtmissed TRUE}
            {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
         }
         {if {modifier_mgr is_modifier_active mod_fastermode}
            {unless {<= $speedmod $leaderspeed}
               {set $speedmod {- $speedmod 0.004}}
               {beatmatch set_music_speed $speedmod}
               {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
               {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
               {{{gamemode get track_panel} find mtv_overlay} setup_text}
            }
         }
      }
   )
   (pass
      {if {! $real_guitar_firstnote} {set $real_guitar_firstnote TRUE}}
      {if {! $real_guitar_milosong} {set $real_guitar_milosong TRUE} {set [num_gems_hit] 1} {set [num_gems_miss] 1} {set [num_gems_pass] 1} {set [num_gems_combo] 1}}
      {set [num_gems_pass] {'+' [num_gems_pass] 1}}
      {set [num_gems_combo] 0}
      {$this check_missed}
      {if {! $real_guitar_caughtmissed}
         {set $real_guitar_caughtmissed TRUE}
         {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
      }
      {if {modifier_mgr is_modifier_active mod_fastermode}
         {unless {<= $speedmod $leaderspeed}
            {set $speedmod {- $speedmod 0.004}}
            {beatmatch set_music_speed $speedmod}
            {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
            {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
            {{{gamemode get track_panel} find mtv_overlay} setup_text}
         }
      }
   )
   (check_fc
      {$this check_missed}
      {if {== {'+' [num_gems_pass] [num_gems_miss]} 0}
         {set $fc TRUE}
      }
   )
   (check_missed
      {if {> {'+' [num_gems_miss] [num_gems_pass]} 0}
         {if {! $real_guitar_caughtmissed}
            {set $real_guitar_caughtmissed TRUE}
            {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
         }
      }
   )
   (num_gems_hit 0)
   (num_gems_combo 0)
   (num_gems_miss 0)
   (num_gems_pass 0)
)
(new Object fc_real_drum_callback ;remove FC groove on real_drum miss/pass
   (hit
      {if {! $real_drum_firstnote} {set $real_drum_firstnote TRUE}}
     {if {! $real_drum_milosong} {set $real_drum_milosong TRUE} {set [num_gems_hit] 0} {set [num_gems_miss] 0} {set [num_gems_pass] 0} {set [num_gems_combo] 0}}
      {$this check_fc}
      {set [num_gems_hit] {'+' [num_gems_hit] 1}}
      {set [num_gems_combo] {'+' [num_gems_combo] 1}}
      {if {modifier_mgr is_modifier_active mod_fastermode}
         {unless {>= $speedmod $speedmod_cap}
            {set $speedmod {+ $speedmod 0.002}}
            {beatmatch set_music_speed $speedmod}
            {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
            {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
            {{{gamemode get track_panel} find mtv_overlay} setup_text}
            {if {> $speedmod $speedmod_top}
               {set $speedmod_top $speedmod}
            }
         }
      }
     )
   (miss
      {unless {! $real_drum_firstnote}
         {set [num_gems_miss] {'+' [num_gems_miss] 1}}
         {set [num_gems_combo] 0}
         {$this check_missed}
         {if {! $real_drum_caughtmissed}
            {set $real_drum_caughtmissed TRUE}
            {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
         }
         {if {modifier_mgr is_modifier_active mod_fastermode}
            {unless {<= $speedmod $leaderspeed}
               {set $speedmod {- $speedmod 0.004}}
               {beatmatch set_music_speed $speedmod}
               {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
               {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
               {{{gamemode get track_panel} find mtv_overlay} setup_text}
            }
         }
      }
   )
   (pass
      {if {! $real_drum_firstnote} {set $real_drum_firstnote TRUE}}
      {if {! $real_drum_milosong} {set $real_drum_milosong TRUE} {set [num_gems_hit] 1} {set [num_gems_miss] 1} {set [num_gems_pass] 1} {set [num_gems_combo] 1}}
      {set [num_gems_pass] {'+' [num_gems_pass] 1}}
      {set [num_gems_combo] 0}
      {$this check_missed}
      {if {! $real_drum_caughtmissed}
         {set $real_drum_caughtmissed TRUE}
         {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
      }
      {if {modifier_mgr is_modifier_active mod_fastermode}
         {unless {<= $speedmod $leaderspeed}
            {set $speedmod {- $speedmod 0.004}}
            {beatmatch set_music_speed $speedmod}
            {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
            {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
            {{{gamemode get track_panel} find mtv_overlay} setup_text}
         }
      }
   )
   (check_fc
      {$this check_missed}
      {if {== {'+' [num_gems_pass] [num_gems_miss]} 0}
         {set $fc TRUE}
      }
   )
   (check_missed
      {if {> {'+' [num_gems_miss] [num_gems_pass]} 0}
         {if {! $real_drum_caughtmissed}
            {set $real_drum_caughtmissed TRUE}
            {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
         }
      }
   )
   (num_gems_hit 0)
   (num_gems_combo 0)
   (num_gems_miss 0)
   (num_gems_pass 0)
)
(new Object fc_bass_callback ;remove FC groove on bass miss/pass
   (hit
      {if {! $bass_firstnote} {set $bass_firstnote TRUE}}
     {if {! $bass_milosong} {set $bass_milosong TRUE} {set [num_gems_hit] 0} {set [num_gems_miss] 0} {set [num_gems_pass] 0} {set [num_gems_combo] 0}}
      {$this check_fc}
      {set [num_gems_hit] {'+' [num_gems_hit] 1}}
      {set [num_gems_combo] {'+' [num_gems_combo] 1}}
      {if {modifier_mgr is_modifier_active mod_fastermode}
         {unless {>= $speedmod $speedmod_cap}
            {set $speedmod {+ $speedmod 0.002}}
            {beatmatch set_music_speed $speedmod}
            {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
            {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
            {{{gamemode get track_panel} find mtv_overlay} setup_text}
            {if {> $speedmod $speedmod_top}
               {set $speedmod_top $speedmod}
            }
         }
      }
     )
   (miss
      {unless {! $bass_firstnote}
         {set [num_gems_miss] {'+' [num_gems_miss] 1}}
         {set [num_gems_combo] 0}
         {$this check_missed}
         {if {! $bass_caughtmissed}
            {set $bass_caughtmissed TRUE}
            {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
         }
         {if {modifier_mgr is_modifier_active mod_fastermode}
            {unless {<= $speedmod $leaderspeed}
               {set $speedmod {- $speedmod 0.004}}
               {beatmatch set_music_speed $speedmod}
               {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
               {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
               {{{gamemode get track_panel} find mtv_overlay} setup_text}
            }
         }
      }
   )
   (pass
      {if {! $bass_firstnote} {set $bass_firstnote TRUE}}
      {if {! $bass_milosong} {set $bass_milosong TRUE} {set [num_gems_hit] 1} {set [num_gems_miss] 1} {set [num_gems_pass] 1} {set [num_gems_combo] 1}}
      {set [num_gems_pass] {'+' [num_gems_pass] 1}}
      {set [num_gems_combo] 0}
      {$this check_missed}
      {if {! $bass_caughtmissed}
         {set $bass_caughtmissed TRUE}
         {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
      }
      {if {modifier_mgr is_modifier_active mod_fastermode}
         {unless {<= $speedmod $leaderspeed}
            {set $speedmod {- $speedmod 0.004}}
            {beatmatch set_music_speed $speedmod}
            {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
            {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
            {{{gamemode get track_panel} find mtv_overlay} setup_text}
         }
      }
   )
   (check_fc
      {$this check_missed}
      {if {== {'+' [num_gems_pass] [num_gems_miss]} 0}
         {set $fc TRUE}
      }
   )
   (check_missed
      {if {> {'+' [num_gems_miss] [num_gems_pass]} 0}
         {if {! $bass_caughtmissed}
            {set $bass_caughtmissed TRUE}
            {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
         }
      }
   )
   (num_gems_hit 0)
   (num_gems_combo 0)
   (num_gems_miss 0)
   (num_gems_pass 0)
)
(new Object fc_real_bass_callback ;remove FC groove on real_bass miss/pass
   (hit
      {if {! $real_bass_firstnote} {set $real_bass_firstnote TRUE}}
     {if {! $real_bass_milosong} {set $real_bass_milosong TRUE} {set [num_gems_hit] 0} {set [num_gems_miss] 0} {set [num_gems_pass] 0} {set [num_gems_combo] 0}}
      {$this check_fc}
      {set [num_gems_hit] {'+' [num_gems_hit] 1}}
      {set [num_gems_combo] {'+' [num_gems_combo] 1}}
      {if {modifier_mgr is_modifier_active mod_fastermode}
         {unless {>= $speedmod $speedmod_cap}
            {set $speedmod {+ $speedmod 0.002}}
            {beatmatch set_music_speed $speedmod}
            {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
            {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
            {{{gamemode get track_panel} find mtv_overlay} setup_text}
            {if {> $speedmod $speedmod_top}
               {set $speedmod_top $speedmod}
            }
         }
      }
     )
   (miss
      {unless {! $real_bass_firstnote}
         {set [num_gems_miss] {'+' [num_gems_miss] 1}}
         {set [num_gems_combo] 0}
         {$this check_missed}
         {if {! $real_bass_caughtmissed}
            {set $real_bass_caughtmissed TRUE}
            {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
         }
         {if {modifier_mgr is_modifier_active mod_fastermode}
            {unless {<= $speedmod $leaderspeed}
               {set $speedmod {- $speedmod 0.004}}
               {beatmatch set_music_speed $speedmod}
               {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
               {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
               {{{gamemode get track_panel} find mtv_overlay} setup_text}
            }
         }
      }
   )
   (pass
      {if {! $real_bass_firstnote} {set $real_bass_firstnote TRUE}}
      {if {! $real_bass_milosong} {set $real_bass_milosong TRUE} {set [num_gems_hit] 1} {set [num_gems_miss] 1} {set [num_gems_pass] 1} {set [num_gems_combo] 1}}
      {set [num_gems_pass] {'+' [num_gems_pass] 1}}
      {set [num_gems_combo] 0}
      {$this check_missed}
      {if {! $real_bass_caughtmissed}
         {set $real_bass_caughtmissed TRUE}
         {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
      }
      {if {modifier_mgr is_modifier_active mod_fastermode}
         {unless {<= $speedmod $leaderspeed}
            {set $speedmod {- $speedmod 0.004}}
            {beatmatch set_music_speed $speedmod}
            {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
            {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
            {{{gamemode get track_panel} find mtv_overlay} setup_text}
         }
      }
   )
   (check_fc
      {$this check_missed}
      {if {== {'+' [num_gems_pass] [num_gems_miss]} 0}
         {set $fc TRUE}
      }
   )
   (check_missed
      {if {> {'+' [num_gems_miss] [num_gems_pass]} 0}
         {if {! $real_bass_caughtmissed}
            {set $real_bass_caughtmissed TRUE}
            {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
         }
      }
   )
   (num_gems_hit 0)
   (num_gems_combo 0)
   (num_gems_miss 0)
   (num_gems_pass 0)
)
(new Object fc_keys_callback ;remove FC groove on keys miss/pass
   (hit
      {if {! $keys_firstnote} {set $keys_firstnote TRUE}}
     {if {! $keys_milosong} {set $keys_milosong TRUE} {set [num_gems_hit] 0} {set [num_gems_miss] 0} {set [num_gems_pass] 0} {set [num_gems_combo] 0}}
      {$this check_fc}
      {set [num_gems_hit] {'+' [num_gems_hit] 1}}
      {set [num_gems_combo] {'+' [num_gems_combo] 1}}
      {if {modifier_mgr is_modifier_active mod_fastermode}
         {unless {>= $speedmod $speedmod_cap}
            {set $speedmod {+ $speedmod 0.002}}
            {beatmatch set_music_speed $speedmod}
            {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
            {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
            {{{gamemode get track_panel} find mtv_overlay} setup_text}
            {if {> $speedmod $speedmod_top}
               {set $speedmod_top $speedmod}
            }
         }
      }
     )
   (miss
      {unless {! $keys_firstnote}
         {set [num_gems_miss] {'+' [num_gems_miss] 1}}
         {set [num_gems_combo] 0}
         {$this check_missed}
         {if {! $keys_caughtmissed}
            {set $keys_caughtmissed TRUE}
            {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
         }
         {if {modifier_mgr is_modifier_active mod_fastermode}
            {unless {<= $speedmod $leaderspeed}
               {set $speedmod {- $speedmod 0.004}}
               {beatmatch set_music_speed $speedmod}
               {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
               {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
               {{{gamemode get track_panel} find mtv_overlay} setup_text}
            }
         }
      }
   )
   (pass
      {if {! $keys_firstnote} {set $keys_firstnote TRUE}}
      {if {! $keys_milosong} {set $keys_milosong TRUE} {set [num_gems_hit] 1} {set [num_gems_miss] 1} {set [num_gems_pass] 1} {set [num_gems_combo] 1}}
      {set [num_gems_pass] {'+' [num_gems_pass] 1}}
      {set [num_gems_combo] 0}
      {$this check_missed}
      {if {! $keys_caughtmissed}
         {set $keys_caughtmissed TRUE}
         {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
      }
      {if {modifier_mgr is_modifier_active mod_fastermode}
         {unless {<= $speedmod $leaderspeed}
            {set $speedmod {- $speedmod 0.004}}
            {beatmatch set_music_speed $speedmod}
            {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
            {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
            {{{gamemode get track_panel} find mtv_overlay} setup_text}
         }
      }
   )
   (check_fc
      {$this check_missed}
      {if {== {'+' [num_gems_pass] [num_gems_miss]} 0}
         {set $fc TRUE}
      }
   )
   (check_missed
      {if {> {'+' [num_gems_miss] [num_gems_pass]} 0}
         {if {! $keys_caughtmissed}
            {set $keys_caughtmissed TRUE}
            {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
         }
      }
   )
   (num_gems_hit 0)
   (num_gems_combo 0)
   (num_gems_miss 0)
   (num_gems_pass 0)
)
(new Object fc_real_keys_callback ;remove FC groove on real_keys miss/pass
   (hit
      {if {! $real_keys_firstnote} {set $real_keys_firstnote TRUE}}
     {if {! $real_keys_milosong} {set $real_keys_milosong TRUE} {set [num_gems_hit] 0} {set [num_gems_miss] 0} {set [num_gems_pass] 0} {set [num_gems_combo] 0}}
      {$this check_fc}
      {set [num_gems_hit] {'+' [num_gems_hit] 1}}
      {set [num_gems_combo] {'+' [num_gems_combo] 1}}
      {if {modifier_mgr is_modifier_active mod_fastermode}
         {unless {>= $speedmod $speedmod_cap}
            {set $speedmod {+ $speedmod 0.002}}
            {beatmatch set_music_speed $speedmod}
            {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
            {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
            {{{gamemode get track_panel} find mtv_overlay} setup_text}
            {if {> $speedmod $speedmod_top}
               {set $speedmod_top $speedmod}
            }
         }
      }
     )
   (miss
      {unless {! $real_keys_firstnote}
         {set [num_gems_miss] {'+' [num_gems_miss] 1}}
         {set [num_gems_combo] 0}
         {$this check_missed}
         {if {! $real_keys_caughtmissed}
            {set $real_keys_caughtmissed TRUE}
            {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
         }
         {if {modifier_mgr is_modifier_active mod_fastermode}
            {unless {<= $speedmod $leaderspeed}
               {set $speedmod {- $speedmod 0.004}}
               {beatmatch set_music_speed $speedmod}
               {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
               {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
               {{{gamemode get track_panel} find mtv_overlay} setup_text}
            }
         }
      }
   )
   (pass
      {if {! $real_keys_firstnote} {set $real_keys_firstnote TRUE}}
      {if {! $real_keys_milosong} {set $real_keys_milosong TRUE} {set [num_gems_hit] 1} {set [num_gems_miss] 1} {set [num_gems_pass] 1} {set [num_gems_combo] 1}}
      {set [num_gems_pass] {'+' [num_gems_pass] 1}}
      {set [num_gems_combo] 0}
      {$this check_missed}
      {if {! $real_keys_caughtmissed}
         {set $real_keys_caughtmissed TRUE}
         {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
      }
      {if {modifier_mgr is_modifier_active mod_fastermode}
         {unless {<= $speedmod $leaderspeed}
            {set $speedmod {- $speedmod 0.004}}
            {beatmatch set_music_speed $speedmod}
            {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
            {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
            {{{gamemode get track_panel} find mtv_overlay} setup_text}
         }
      }
   )
   (check_fc
      {$this check_missed}
      {if {== {'+' [num_gems_pass] [num_gems_miss]} 0}
         {set $fc TRUE}
      }
   )
   (check_missed
      {if {> {'+' [num_gems_miss] [num_gems_pass]} 0}
         {if {! $real_keys_caughtmissed}
            {set $real_keys_caughtmissed TRUE}
            {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
         }
      }
   )
   (num_gems_hit 0)
   (num_gems_combo 0)
   (num_gems_miss 0)
   (num_gems_pass 0)
)
(new Object fc_drum_callback ;remove FC groove on drum miss/pass
   (hit
      {if {! $drum_firstnote} {set $drum_firstnote TRUE}}
     {if {! $drum_milosong} {set $drum_milosong TRUE} {set [num_gems_hit] 0} {set [num_gems_miss] 0} {set [num_gems_pass] 0} {set [num_gems_combo] 0}}
      {$this check_fc}
      {set [num_gems_hit] {'+' [num_gems_hit] 1}}
      {set [num_gems_combo] {'+' [num_gems_combo] 1}}
      {if {modifier_mgr is_modifier_active mod_fastermode}
         {unless {>= $speedmod $speedmod_cap}
            {set $speedmod {+ $speedmod 0.002}}
            {beatmatch set_music_speed $speedmod}
            {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
            {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
            {{{gamemode get track_panel} find mtv_overlay} setup_text}
            {if {> $speedmod $speedmod_top}
               {set $speedmod_top $speedmod}
            }
         }
      }
     )
   (miss
      {unless {! $drum_firstnote}
         {set [num_gems_miss] {'+' [num_gems_miss] 1}}
         {set [num_gems_combo] 0}
         {$this check_missed}
         {if {! $drum_caughtmissed}
            {set $drum_caughtmissed TRUE}
            {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
         }
         {if {modifier_mgr is_modifier_active mod_fastermode}
            {unless {<= $speedmod $leaderspeed}
               {set $speedmod {- $speedmod 0.004}}
               {beatmatch set_music_speed $speedmod}
               {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
               {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
               {{{gamemode get track_panel} find mtv_overlay} setup_text}
            }
         }
      }
   )
   (pass
      {if {! $drum_firstnote} {set $drum_firstnote TRUE}}
      {if {! $drum_milosong} {set $drum_milosong TRUE} {set [num_gems_hit] 1} {set [num_gems_miss] 1} {set [num_gems_pass] 1} {set [num_gems_combo] 1}}
      {set [num_gems_pass] {'+' [num_gems_pass] 1}}
      {set [num_gems_combo] 0}
      {$this check_missed}
      {if {! $drum_caughtmissed}
         {set $drum_caughtmissed TRUE}
         {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
      }
      {if {modifier_mgr is_modifier_active mod_fastermode}
         {unless {<= $speedmod $leaderspeed}
            {set $speedmod {- $speedmod 0.004}}
            {beatmatch set_music_speed $speedmod}
            {{{gamemode get track_panel} loaded_dir} set view_time_easy {* {/ 2.4 $trackspeed} $speedmod}} ;implement track speed modifier
            {{{gamemode get track_panel} loaded_dir} set view_time_expert {* {/ 1.2 $trackspeed} $speedmod}}
            {{{gamemode get track_panel} find mtv_overlay} setup_text}
         }
      }
   )
   (check_fc
      {$this check_missed}
      {if {== {'+' [num_gems_pass] [num_gems_miss]} 0}
         {set $fc TRUE}
      }
   )
   (check_missed
      {if {> {'+' [num_gems_miss] [num_gems_pass]} 0}
         {if {! $drum_caughtmissed}
            {set $drum_caughtmissed TRUE}
            {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex {coop_track_panel find multframe.tex}}}
         }
      }
   )
   (num_gems_hit 0)
   (num_gems_combo 0)
   (num_gems_miss 0)
   (num_gems_pass 0)
)
#define TRACK_PANEL_HANDLERS
((enter
         {if_else $fcringonce
            {do
               {{coop_track_panel find fcframe.tex} set_bitmap {sprint "ui/track/multiplier_ring/streak_meter_plate_fc_" $multiring ".png"}}
               {{coop_track_panel find multframe.tex} set_bitmap {sprint "ui/track/multiplier_ring/streak_meter_plate_" $multiring ".png"}}
               {{coop_track_panel find streak_meter_plate.tex} iterate_refs $ref {$ref set diffuse_tex fcframe.tex}}
               {{coop_track_panel find fcframe.tex} iterate_refs $ref {$ref set diffuse_tex fcframe.tex}}
               {{coop_track_panel find multframe.tex} iterate_refs $ref {$ref set diffuse_tex fcframe.tex}}
            }
            {do
               {set $fcringonce TRUE}
               {new Tex fcframe.tex}
               {new Tex multframe.tex}
               {{coop_track_panel find streak_meter_plate.tex} iterate_refs $ref {$ref set diffuse_tex fcframe.tex}}
                  {do
                     {{coop_track_panel find fcframe.tex} set_bitmap {sprint "ui/track/multiplier_ring/streak_meter_plate_fc_" $multiring ".png"}}
                     {{coop_track_panel find multframe.tex} set_bitmap {sprint "ui/track/multiplier_ring/streak_meter_plate_" $multiring ".png"}}
                  }
            }
         }
      {game add_sink $this}
      {beatmatch foreach_active_player $player ;handle adding the appropriate callbacks to each player
         {switch {$player instrument}
            (bass {$player add_sink fc_bass_callback (hit miss pass check_fc check_missed num_gems_hit num_gems_combo num_gems_miss num_gems_pass)})
            (real_guitar {$player add_sink fc_real_guitar_callback (hit miss pass check_fc check_missed num_gems_hit num_gems_combo num_gems_miss num_gems_pass)})
            (real_bass {$player add_sink fc_real_bass_callback (hit miss pass check_fc check_missed num_gems_hit num_gems_combo num_gems_miss num_gems_pass)})
            (keys {$player add_sink fc_keys_callback (hit miss pass check_fc check_missed num_gems_hit num_gems_combo num_gems_miss num_gems_pass)})
            (real_keys {$player add_sink fc_real_keys_callback (hit miss pass check_fc check_missed num_gems_hit num_gems_combo num_gems_miss num_gems_pass)})
            (guitar {$player add_sink fc_guitar_callback (hit miss pass check_fc check_missed num_gems_hit num_gems_combo num_gems_miss num_gems_pass)})
            (drum {$player add_sink fc_drum_callback (hit miss pass check_fc check_missed num_gems_hit num_gems_combo num_gems_miss num_gems_pass)})
            (real_drum {$player add_sink fc_real_drum_callback (hit miss pass check_fc check_missed num_gems_hit num_gems_combo num_gems_miss num_gems_pass)})
         }
      }
      {$this
         set_showing
         {!
            {gamemode in_mode practice}}})
   (exit
      {if {exists animated_gems} ;check if the above task is running
   {delete animated_gems} ;delete the task if running
}
      {game remove_sink $this})
   (unison_hit)
   (set_track_out)
   (set_track_in)
   (animate_track
      ($start $end $period $units))
   (animate_track_out)
   (animate_track_out_fast)
   (animate_track_in_fast)
   (finish_load
      {$this set_showing FALSE}
      {$this set_track_out})
   (intro_start
      {$this track_reset}
      {$this set_showing TRUE}
      {$this set_track_in})
   (intro_skip
      {$this track_reset}
      {$this set_showing TRUE}
      {$this set_track_out}
{if {&& {modifier_mgr is_modifier_active mod_nobre} $imabigboy}
         {if {! $already_restarted} ;cheap attempt to fix the "notes too quick bug" by restarting once automatically on initial song start, this will at least work in black bg
            {do
               {set $imabigboy FALSE}
               {set $already_restarted TRUE}
               {{{beatmatch active_player 0} get_user} set_difficulty kDifficultyExpert}
               {game_restart}
            }
         }
      }
   )
   (on_reset
      {beatmatch
         foreach_active_player
         $m
         {$m on_new_track}})
   (on_extend
{if {&& {modifier_mgr is_modifier_active mod_nobre} $imabigboy}
         {if {! $already_restarted} ;cheap attempt to fix the "notes too quick bug" by restarting once automatically on initial song start, this will at least work in black bg
            {do
               {set $imabigboy FALSE}
               {set $already_restarted TRUE}
               {{{beatmatch active_player 0} get_user} set_difficulty kDifficultyExpert}
               {game_restart}
            }
         }
      }


;populate texture array if an animated smasher texture modifier is on
{if $animatedsmasherscustomtexture
   {if $animatedsmashers
      {if {== {$user get_track_type} kTrackDrum} 
      {set $drumframearray (drumframe0.tex drumframe1.tex drumframe2.tex drumframe3.tex drumframe4.tex drumframe5.tex drumframe6.tex
drumframe7.tex drumframe8.tex drumframe9.tex drumframe10.tex drumframe11.tex drumframe12.tex drumframe13.tex drumframe14.tex
drumframe15.tex drumframe16.tex drumframe17.tex drumframe18.tex drumframe19.tex drumframe20.tex drumframe21.tex drumframe22.tex
drumframe23.tex drumframe24.tex drumframe25.tex drumframe26.tex drumframe27.tex drumframe28.tex drumframe29.tex drumframe30.tex
drumframe31.tex drumframe32.tex drumframe33.tex drumframe34.tex drumframe35.tex drumframe36.tex drumframe37.tex drumframe38.tex
drumframe39.tex drumframe40.tex drumframe41.tex drumframe42.tex drumframe43.tex drumframe44.tex drumframe45.tex drumframe46.tex
drumframe47.tex drumframe48.tex drumframe49.tex drumframe50.tex drumframe51.tex drumframe52.tex drumframe53.tex drumframe54.tex
drumframe55.tex drumframe56.tex drumframe57.tex drumframe58.tex drumframe59.tex drumframe60.tex)}}

;populate texture array if an animated smasher texture modifier is on
{|| {$user get_track_type} kTrackGuitar kTrackBass kTrackKeys}
{set $guitarframearray (guitarframe0.tex guitarframe1.tex guitarframe2.tex guitarframe3.tex guitarframe4.tex guitarframe5.tex guitarframe6.tex
guitarframe7.tex guitarframe8.tex guitarframe9.tex guitarframe10.tex guitarframe11.tex guitarframe12.tex guitarframe13.tex guitarframe14.tex
guitarframe15.tex guitarframe16.tex guitarframe17.tex guitarframe18.tex guitarframe19.tex guitarframe20.tex guitarframe21.tex guitarframe22.tex
guitarframe23.tex guitarframe24.tex guitarframe25.tex guitarframe26.tex guitarframe27.tex guitarframe28.tex guitarframe29.tex guitarframe30.tex
guitarframe31.tex guitarframe32.tex guitarframe33.tex guitarframe34.tex guitarframe35.tex guitarframe36.tex guitarframe37.tex guitarframe38.tex
guitarframe39.tex guitarframe40.tex guitarframe41.tex guitarframe42.tex guitarframe43.tex guitarframe44.tex guitarframe45.tex guitarframe46.tex
guitarframe47.tex guitarframe48.tex guitarframe49.tex guitarframe50.tex guitarframe51.tex guitarframe52.tex guitarframe53.tex guitarframe54.tex
guitarframe55.tex guitarframe56.tex guitarframe57.tex guitarframe58.tex guitarframe59.tex guitarframe60.tex)}}}

;populate animated smasher bitmaps
{if $animatedsmasherscustomtexture
   {if $animatedsmashers
      {set $framecountbit 0}
      {thread_task kTaskSeconds
         (script
            {if {|| {$user get_track_type} kTrackGuitar kTrackBass kTrackKeys} {new Tex {sprint "guitarframe" $framecountbit ".tex"}}}
            {if {== {$user get_track_type} kTrackDrum} {new Tex {sprint "drumframe" $framecountbit ".tex"}}}
            {if {|| {$user get_track_type} kTrackGuitar kTrackBass kTrackKeys} {{sprint "guitarframe" $framecountbit ".tex"} set_bitmap {sprint "ui/track/animated_smashers/gem_smasher_guitar_" $animatedsmashername "/gem_smasher_guitar_" $animatedsmashername "_" $framecountbit ".png"}}}
            {if {== {$user get_track_type} kTrackDrum} {{sprint "drumframe" $framecountbit ".tex"} set_bitmap {sprint "ui/track/animated_smashers/gem_smasher_drum_" $animatedsmashername "/gem_smasher_drum_" $animatedsmashername "_" $framecountbit ".png"}}}
            {set $framecountbit {+ $framecountbit 1}}
            {unless {>= $framecountbit 60} {$task loop}}
         )
      }
   }
}

;apply animated smasher in game task
{if $animatedsmashers
   {set $framecountdif 0}
   {thread_task kTaskSeconds
      (delay 0.4)
      (script
         {if {== {$user get_track_type} kTrackDrum} {gem_smasher_drum.mat set diffuse_tex {elem $drumframearray $framecountdif}}}
         {if {|| {$user get_track_type} kTrackGuitar kTrackBass kTrackKeys} {gem_smasher_guitar.mat set diffuse_tex {elem $guitarframearray $framecountdif}}}
         {set $framecountdif {+ $framecountdif 1}}
         {$task sleep 0.016}
         {if {>= $framecountdif 60} {set $framecountdif 0}}
         {$task loop}
      )
   }
}

;populate memory with animated gems textures for replacement
{if $animatedgemscustomtexture ;if we have an animated gem update queued
   {if $animatedgems ;if we have animated gems enabled
      {set $gemframecounttex 0} ;we need to ensure we start at 0 before running the following task
      {thread_task kTaskSeconds ;create a new task
         (script ;task contents
            {if {|| {$user get_track_type} kTrackDrum kTrackGuitar kTrackBass kTrackKeys kTrackRealKeys} ;check the currently loaded instrument
               {new Tex {sprint "gemframe" $gemframecounttex ".tex"}} ;create a new texture with a numerical index of the currently tracked variable for it's specific instrument gem type
               {{sprint "gemframe" $gemframecounttex ".tex"} set_bitmap {sprint "ui/track/animated_gems/prism_gems_" $animatedgemname "/prism_gems_" $animatedgemname "_" $gemframecounttex ".png"}} ;populate the currently created texture index with the selected animated gem index for it's specific instrument gem type
            }
            {if {== {$user get_track_type} kTrackDrum} ;check the currently loaded instrument
               {new Tex {sprint "gemdrumframe" $gemframecounttex ".tex"}} ;create a new texture with a numerical index of the currently tracked variable for it's specific instrument gem type
               {{sprint "gemdrumframe" $gemframecounttex ".tex"} set_bitmap {sprint "ui/track/animated_gems/gem_cymbal_diffuse_" $animatedgemname "/gem_cymbal_diffuse_" $animatedgemname "_" $gemframecounttex ".png"}} ;populate the currently created texture index with the selected animated gem index for it's specific instrument gem type
            }
            {if {== {$user get_track_type} kTrackRealKeys} ;check the currently loaded instrument
               {new Tex {sprint "gemkeysframe" $gemframecounttex ".tex"}} ;create a new texture with a numerical index of the currently tracked variable for it's specific instrument gem type
               {{sprint "gemkeysframe" $gemframecounttex ".tex"} set_bitmap {sprint "ui/track/animated_gems/prism_gem_keyboard_style_" $animatedgemname "/prism_gem_keyboard_style_" $animatedgemname "_" $gemframecounttex ".png"}} ;populate the currently created texture index with the selected animated gem index for it's specific instrument gem type
            }
            {set $gemframecounttex {+ $gemframecounttex 1}} ;increment the variable to setup the next texture creation index
            {unless {>= $gemframecounttex 60} ;only run the task until the variable reaches 60
               {$task loop} ;loop the task if variable is below 60
            }
         )
      }
   }
}

;apply animated gems in game task
{if {exists animated_gems} ;check if the above task is running
   {delete animated_gems} ;delete the task if running
}
{if $animatedgems ;if we have animated gem enabled
   {set $gemframecountdif 0} ;we need to ensure we start at 0 before running the following task
   {thread_task kTaskSeconds ;create a new task
      (name animated_gems) ;name the current task for deletion tracking
      (delay 0.1) ;delay the start of the task
      (script ;task contents
         {if {== {$user get_track_type} kTrackDrum} ;check the currently loaded instrument
            {gem_cymbal_diffuse.tex iterate_refs $ref {$ref set diffuse_tex {sprint 'gemdrumframe' $gemframecountdif '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
            {gem_cymbal_ems.tex iterate_refs $ref {$ref set diffuse_tex {sprint 'gemdrumframe' $gemframecountdif '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
         }
         {if {|| {$user get_track_type} kTrackDrum kTrackGuitar kTrackBass kTrackKeys kTrackRealKeys} ;check the currently loaded instrument
            {prism_gems.tex iterate_refs $ref {$ref set diffuse_tex {sprint 'gemframe' $gemframecountdif '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
            {prism_gem_emissive.tex iterate_refs $ref {$ref set diffuse_tex {sprint 'gemframe' $gemframecountdif '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
         }
         {if {== {$user get_track_type} kTrackRealKeys} ;check the currently loaded instrument
            {prism_gem_keyboard_style.tex iterate_refs $ref {$ref set diffuse_tex {sprint 'gemkeysframe' $gemframecountdif '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
         }
         {set $gemframecountdif {+ $gemframecountdif 1}} ;increment the variable to setup the next texture application index
         {$task sleep 0.016} ;delay the next step of the task for roughly 1 frame at 60fps
         {if {>= $gemframecountdif 60} {set $gemframecountdif 0}} ;only run the task until the variable reaches 60
         {$task loop} ;loop the task
      )
   }
}

;populate animated highway bitmaps
{if $animatedhighwaycustomtexture ;if we have an animated highway update queued
   {if $animatedhighway ;if we have animated highway enabled
      {set $highframecountbit 0} ;we need to ensure we start at 0 before running the following task
      {thread_task kTaskSeconds ;create a new task
         (script ;task contents
            {new Tex {sprint "highframe" $highframecountbit ".tex"}} ;create a new texture with a numerical index of the currently tracked variable
            {{sprint "highframe" $highframecountbit ".tex"} set_bitmap {sprint "ui/track/animated_surfaces/" $animatedhighwayname "/" $animatedhighwayname "_" $highframecountbit ".png"}} ;populate the currently created texture index with the selected animated highway index
            {set $highframecountbit {+ $highframecountbit 1}} ;increment the variable to setup the next texture creation index
            {unless {>= $highframecountbit 60} ;only run the task until the variable reaches 60
               {$task loop} ;loop the task if variable is below 60
            }
         )
      }
   }
}

{if {exists animated_highway} ;check if the above task is running
   {delete animated_highway} ;delete the task if running
}
;apply animated highway in game task
{if $animatedhighway ;if we have animated highway enabled
   {set $highframecount 0} ;we need to ensure we start at 0 before running the following task
   {thread_task kTaskSeconds ;create a new task
      (name animated_highway) ;name the current task for deletion tracking
      (delay 0.1) ;delay the start of the task
      (script ;task contents
         {if {|| {$user get_track_type} kTrackBass kTrackGuitar kTrackRealBass kTrackRealGuitar} ;check the currently loaded instrument
            {watermark_bass.tex set_bitmap {sprint "ui/track/highways/_no_highway.png"}} ;hide the original texture that we aren't using during animated highway mode
            {watermark_guitar.tex set_bitmap {sprint "ui/track/highways/_no_highway.png"}} ;hide the original texture that we aren't using during animated highway mode
            {watermark_bass.tex iterate_refs $ref {$ref set prelit FALSE}} ;setting prelit to false makes the highways pop visually
            {watermark_guitar.tex iterate_refs $ref {$ref set prelit FALSE}} ;setting prelit to false makes the highways pop visually
            {watermark_bass.tex iterate_refs $ref {$ref set diffuse_tex {sprint 'highframe' $highframecount '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
            {watermark_guitar.tex iterate_refs $ref {$ref set diffuse_tex {sprint 'highframe' $highframecount '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
         }
         {if {== {$user get_track_type} kTrackDrum} ;check the currently loaded instrument
            {watermark_drum.tex set_bitmap {sprint "ui/track/highways/_no_highway.png"}} ;hide the original texture that we aren't using during animated highway mode
            {watermark_drum.tex iterate_refs $ref {$ref set prelit FALSE}} ;setting prelit to false makes the highways pop visually
            {watermark_drum.tex iterate_refs $ref {$ref set diffuse_tex {sprint 'highframe' $highframecount '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
         }
         {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} ;check the currently loaded instrument
            {watermark_keys.tex set_bitmap {sprint "ui/track/highways/_no_highway.png"}} ;hide the original texture that we aren't using during animated highway mode
            {watermark_keys.tex iterate_refs $ref {$ref set prelit FALSE}} ;setting prelit to false makes the highways pop visually
            {watermark_keys.tex iterate_refs $ref {$ref set diffuse_tex {sprint 'highframe' $highframecount '.tex'}}} ;apply the currently selected animated texture index with the selected animated highway index image we pre generated
         }
         {set $highframecount {+ $highframecount 1}} ;increment the variable to setup the next texture application index
         {$task sleep 0.041} ;delay the next step of the task for roughly 1 frame at 30fps
         {if {>= $highframecount 60} {set $highframecount 0}} ;only run the task until the variable reaches 60
         {$task loop} ;loop the task
      )
   }
}

;setup emissive textures per instrument to use later
#define GTR_EMISSIVE_HANDLER
(
   {if {|| {$user get_track_type} kTrackGuitar kTrackRealGuitar} ;check if the instrument is currently loaded on screen
      {spotlight_guitar_track_emissive.tex set_bitmap {sprint "ui/track/emissives/" $emissivegtr ".png"}} ;load selected texture into tex memory
      {spotlight_guitar_track_emissive.tex iterate_refs $ref {$ref set diffuse_tex spotlight_guitar_track_emissive.tex}} ;load the tex into the material
      {spotlight_guitar_track_emissive.tex iterate_refs $ref {$ref set emissive_map spotlight_guitar_track_emissive.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_guitar_track_emissive.tex iterate_refs $ref {$ref set color {pack_color $emissive_r $emissive_g $emissive_b}}} ;apply the custom color selected to the material
      {spotlight_guitar_track_emissive.tex iterate_refs $ref {$ref set intensify TRUE}} ;double the intensity of the material so it looks brighter and vibrant
   }
)

#define BASS_EMISSIVE_HANDLER
(
   {if {|| {$user get_track_type} kTrackBass kTrackRealBass} ;check if the instrument is currently loaded on screen
      {spotlight_bass_track_emissive.tex set_bitmap {sprint "ui/track/emissives/" $emissivebass ".png"}} ;load selected texture into tex memory
      {spotlight_bass_track_emissive.tex iterate_refs $ref {$ref set diffuse_tex spotlight_bass_track_emissive.tex}} ;load the tex into the material
      {spotlight_bass_track_emissive.tex iterate_refs $ref {$ref set emissive_map spotlight_bass_track_emissive.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_bass_track_emissive.tex iterate_refs $ref {$ref set color {pack_color $emissive_r $emissive_g $emissive_b}}} ;apply the custom color selected to the material
      {spotlight_bass_track_emissive.tex iterate_refs $ref {$ref set intensify TRUE}} ;double the intensity of the material so it looks brighter and vibrant
   }
)

#define DRUM_EMISSIVE_HANDLER
(
   {if {== {$user get_track_type} kTrackDrum} ;check if the instrument is currently loaded on screen
      {spotlight_drums_track_emissive.tex set_bitmap {sprint "ui/track/emissives/" $emissivedrum ".png"}} ;load selected texture into tex memory
      {spotlight_drum_track_emissive.tex iterate_refs $ref {$ref set diffuse_tex spotlight_drum_track_emissive.tex}} ;load the tex into the material
      {spotlight_drum_track_emissive.tex iterate_refs $ref {$ref set emissive_map spotlight_drum_track_emissive.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_drum_track_emissive.tex iterate_refs $ref {$ref set color {pack_color $emissive_r $emissive_g $emissive_b}}} ;apply the custom color selected to the material
      {spotlight_drum_track_emissive.tex iterate_refs $ref {$ref set intensify TRUE}} ;double the intensity of the material so it looks brighter and vibrant
   }
)
#define KEYS_EMISSIVE_HANDLER
(
   {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} ;check if the instrument is currently loaded on screen
      {spotlight_keys_track_emissive.tex set_bitmap {sprint "ui/track/emissives/" $emissivekeys ".png"}} ;load selected texture into tex memory
      {spotlight_prokeys_track_emissive.tex set_bitmap {sprint "ui/track/emissives/" $emissivekeys ".png"}} ;load selected texture into tex memory
      {spotlight_keys_track_emissive.tex iterate_refs $ref {$ref set diffuse_tex spotlight_keys_track_emissive.tex}} ;load the tex into the material
      {spotlight_prokeys_track_emissive.tex iterate_refs $ref {$ref set diffuse_tex spotlight_prokeys_track_emissive.tex}} ;load the tex into the material
      {spotlight_keys_track_emissive.tex iterate_refs $ref {$ref set emissive_map spotlight_keys_track_emissive.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_prokeys_track_emissive.tex iterate_refs $ref {$ref set emissive_map spotlight_prokeys_track_emissive.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_keys_track_emissive.tex iterate_refs $ref {$ref set color {pack_color $emissive_r $emissive_g $emissive_b}}} ;apply the custom color selected to the material
      {spotlight_prokeys_track_emissive.tex iterate_refs $ref {$ref set color {pack_color $emissive_r $emissive_g $emissive_b}}} ;apply the custom color selected to the material
      {spotlight_keys_track_emissive.tex iterate_refs $ref {$ref set intensify TRUE}} ;double the intensity of the material so it looks brighter and vibrant
      {spotlight_prokeys_track_emissive.tex iterate_refs $ref {$ref set intensify TRUE}} ;double the intensity of the material so it looks brighter and vibrant
   }
)

{if $emissivecustomtexture ;if we are queued to update an emissive texture
   {unless {== $emissive none} ;check the texture is not set to default
      {if {== {$user get_track_type} kTrackDrum} ;check if the instrument is currently loaded on screen
         {set $emissivedrum $emissive} ;set the per instrument emissive temporarily to the overall emissive selected
         {set $emissivedrumcustomtexture TRUE} ;queue an update to the per instrument emissive of a currently loaded instrument
      }
      {if {|| {$user get_track_type} kTrackBass kTrackRealBass} ;check if the instrument is currently loaded on screen
         {set $emissivebass $emissive} ;set the per instrument emissive temporarily to the overall emissive selected
         {set $emissivebasscustomtexture TRUE} ;queue an update to the per instrument emissive of a currently loaded instrument
      }
      {if {|| {$user get_track_type} kTrackGuitar kTrackRealGuitar} ;check if the instrument is currently loaded on screen
         {set $emissivegtr $emissive} ;set the per instrument emissive temporarily to the overall emissive selected
         {set $emissivegtrcustomtexture TRUE} ;queue an update to the per instrument emissive of a currently loaded instrument
      }
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} ;check if the instrument is currently loaded on screen
         {set $emissivekeys $emissive} ;set the per instrument emissive temporarily to the overall emissive selected
         {set $emissivekeyscustomtexture TRUE} ;queue an update to the per instrument emissive of a currently loaded instrument
      }
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} ;check if the instrument is currently loaded on screen
         {set $emissivekeys $emissive} ;set the per instrument emissive temporarily to the overall emissive selected
         {set $emissivekeyscustomtexture TRUE} ;queue an update to the per instrument emissive of a currently loaded instrument
      }
   }
}

{if $emissivegtrcustomtexture ;if we are queued to update a per instrument emissive texture
   {unless {== $emissivegtr none} ;check the texture is not set to default
      GTR_EMISSIVE_HANDLER ;apply the emissive to the instrument if available
      {unless {== $emissive none} ;if we came here from all instrument emissive
         {set $emissivegtr none} ;reset per inst emissive
      }
   }
}

{if $emissivebasscustomtexture ;if we are queued to update a per instrument emissive texture
   {unless {== $emissivebass none} ;check the texture is not set to default
      BASS_EMISSIVE_HANDLER ;apply the emissive to the instrument if available
      {unless {== $emissive none} ;if we came here from all instrument emissive
         {set $emissivebass none} ;reset per inst emissive
      }
   }
}

{if $emissivedrumcustomtexture ;if we are queued to update a per instrument emissive texture
   {unless {== $emissivedrum none} ;check the texture is not set to default
      DRUM_EMISSIVE_HANDLER ;apply the emissive to the instrument if available
      {unless {== $emissive none} ;if we came here from all instrument emissive
         {set $emissivedrum none} ;reset per inst emissive
      }
   }
}

{if $emissivekeyscustomtexture ;if we are queued to update a per instrument emissive texture
   {unless {== $emissivekeys none} ;check the texture is not set to default
      KEYS_EMISSIVE_HANDLER ;apply the emissive to the instrument if available
      {unless {== $emissive none} ;if we came here from all instrument emissive
         {set $emissivekeys none} ;reset per inst emissive
      }
   }
}

;setup spotlight textures per instrument to use later
#define GTR_SPOTLIGHT_HANDLER
(
   {if {|| {$user get_track_type} kTrackGuitar kTrackRealGuitar} ;check if the instrument is currently loaded on screen
      {spotlight_guitar_track.tex set_bitmap {sprint "ui/track/spotlights/" $spotlightgtr ".png"}} ;load selected texture into tex memory
      {spotlight_guitar_track.tex iterate_refs $ref {$ref set diffuse_tex spotlight_guitar_track.tex}} ;load the tex into the material
      {spotlight_guitar_track.tex iterate_refs $ref {$ref set emissive_map spotlight_guitar_track.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_guitar_track.tex iterate_refs $ref {$ref set color {pack_color $spotlight_r $spotlight_g $spotlight_b}}} ;apply the custom color selected to the material
      {spotlight_guitar_track.tex iterate_refs $ref {$ref set intensify TRUE}} ;double the intensity of the material so it looks brighter and vibrant
   }
)

#define BASS_SPOTLIGHT_HANDLER
(
   {if {|| {$user get_track_type} kTrackBass kTrackRealBass} ;check if the instrument is currently loaded on screen
      {spotlight_bass_track.tex set_bitmap {sprint "ui/track/spotlights/" $spotlightbass ".png"}} ;load selected texture into tex memory
      {spotlight_bass_track.tex iterate_refs $ref {$ref set diffuse_tex spotlight_bass_track.tex}} ;load the tex into the material
      {spotlight_bass_track.tex iterate_refs $ref {$ref set emissive_map spotlight_bass_track.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_bass_track.tex iterate_refs $ref {$ref set color {pack_color $spotlight_r $spotlight_g $spotlight_b}}} ;apply the custom color selected to the material
      {spotlight_bass_track.tex iterate_refs $ref {$ref set intensify TRUE}} ;double the intensity of the material so it looks brighter and vibrant
   }
)

#define DRUM_SPOTLIGHT_HANDLER
(
   {if {== {$user get_track_type} kTrackDrum} ;check if the instrument is currently loaded on screen
      {spotlight_drums_track.tex set_bitmap {sprint "ui/track/spotlights/" $spotlightdrum ".png"}} ;load selected texture into tex memory
      {spotlight_drum_track.tex iterate_refs $ref {$ref set diffuse_tex spotlight_drum_track.tex}} ;load the tex into the material
      {spotlight_drum_track.tex iterate_refs $ref {$ref set emissive_map spotlight_drum_track.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_drum_track.tex iterate_refs $ref {$ref set color {pack_color $spotlight_r $spotlight_g $spotlight_b}}} ;apply the custom color selected to the material
      {spotlight_drum_track.tex iterate_refs $ref {$ref set intensify TRUE}} ;double the intensity of the material so it looks brighter and vibrant
   }
)
#define KEYS_SPOTLIGHT_HANDLER
(
   {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} ;check if the instrument is currently loaded on screen
      {spotlight_prokeys_track.tex set_bitmap {sprint "ui/track/spotlights/" $spotlightkeys ".png"}} ;load selected texture into tex memory
      {spotlight_keys_track.tex set_bitmap {sprint "ui/track/spotlights/" $spotlightkeys ".png"}} ;load selected texture into tex memory
      {spotlight_prokeys_track.tex iterate_refs $ref {$ref set diffuse_tex spotlight_prokeys_track.tex}} ;load the tex into the material
      {spotlight_keys_track.tex iterate_refs $ref {$ref set diffuse_tex spotlight_keys_track.tex}} ;load the tex into the material
      {spotlight_prokeys_track.tex iterate_refs $ref {$ref set emissive_map spotlight_prokeys_track.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_keys_track.tex iterate_refs $ref {$ref set emissive_map spotlight_keys_track.tex}} ;apply the emissive map as well so it looks proper
      {spotlight_prokeys_track.tex iterate_refs $ref {$ref set color {pack_color $spotlight_r $spotlight_g $spotlight_b}}} ;apply the custom color selected to the material
      {spotlight_keys_track.tex iterate_refs $ref {$ref set color {pack_color $spotlight_r $spotlight_g $spotlight_b}}} ;apply the custom color selected to the material
      {spotlight_prokeys_track.tex iterate_refs $ref {$ref set intensify TRUE}} ;double the intensity of the material so it looks brighter and vibrant
      {spotlight_keys_track.tex iterate_refs $ref {$ref set intensify TRUE}} ;double the intensity of the material so it looks brighter and vibrant
   }
)

{if $spotlightcustomtexture ;if we are queued to update an spotlight texture
   {unless {== $spotlight none} ;check the texture is not set to default
      {if {== {$user get_track_type} kTrackDrum} ;check if the instrument is currently loaded on screen
         {set $spotlightdrum $spotlight} ;set the per instrument spotlight temporarily to the overall spotlight selected
         {set $spotlightdrumcustomtexture TRUE} ;queue an update to the per instrument spotlight of a currently loaded instrument
      }
      {if {|| {$user get_track_type} kTrackBass kTrackRealBass} ;check if the instrument is currently loaded on screen
         {set $spotlightbass $spotlight} ;set the per instrument spotlight temporarily to the overall spotlight selected
         {set $spotlightbasscustomtexture TRUE} ;queue an update to the per instrument spotlight of a currently loaded instrument
      }
      {if {|| {$user get_track_type} kTrackGuitar kTrackRealGuitar} ;check if the instrument is currently loaded on screen
         {set $spotlightdrum $spotlight} ;set the per instrument spotlight temporarily to the overall spotlight selected
         {set $spotlightdrumcustomtexture TRUE} ;queue an update to the per instrument spotlight of a currently loaded instrument
      }
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} ;check if the instrument is currently loaded on screen
         {set $spotlightkeys $spotlight} ;set the per instrument spotlight temporarily to the overall spotlight selected
         {set $spotlightkeyscustomtexture TRUE} ;queue an update to the per instrument spotlight of a currently loaded instrument
      }
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} ;check if the instrument is currently loaded on screen
         {set $spotlightkeys $spotlight} ;set the per instrument spotlight temporarily to the overall spotlight selected
         {set $spotlightkeyscustomtexture TRUE} ;queue an update to the per instrument spotlight of a currently loaded instrument
      }
   }
}

{if $spotlightgtrcustomtexture ;if we are queued to update a per instrument spotlight texture
   {unless {== $spotlightgtr none} ;check the texture is not set to default
      GTR_SPOTLIGHT_HANDLER ;apply the spotlight to the instrument if available
      {unless {== $spotlight none} ;if we came here from all instrument spotlight
         {set $spotlightgtr none} ;reset per inst spotlight
      }
   }
}

{if $spotlightbasscustomtexture ;if we are queued to update a per instrument spotlight texture
   {unless {== $spotlightbass none} ;check the texture is not set to default
      BASS_SPOTLIGHT_HANDLER ;apply the spotlight to the instrument if available
      {unless {== $spotlight none} ;if we came here from all instrument spotlight
         {set $spotlightbass none} ;reset per inst spotlight
      }
   }
}

{if $spotlightdrumcustomtexture ;if we are queued to update a per instrument spotlight texture
   {unless {== $spotlightdrum none} ;check the texture is not set to default
      DRUM_SPOTLIGHT_HANDLER ;apply the spotlight to the instrument if available
      {unless {== $spotlight none} ;if we came here from all instrument spotlight
         {set $spotlightdrum none} ;reset per inst spotlight
      }
   }
}

{if $spotlightkeyscustomtexture ;if we are queued to update a per instrument spotlight texture
   {unless {== $spotlightkeys none}
      KEYS_SPOTLIGHT_HANDLER ;apply the spotlight to the instrument if available
      {unless {== $spotlight none} ;if we came here from all instrument spotlight
         {set $spotlightkeys none} ;reset per inst spotlight
      }
   }
}

{if $highwaycustomtexture
   {unless {== $highway none}
      {if {== {$user get_track_type} kTrackDrum} {watermark_drum.tex set_bitmap {sprint "ui/track/highways/" $highway ".png"}}}
      {if {|| {$user get_track_type} kTrackBass kTrackRealBass} {watermark_bass.tex set_bitmap {sprint "ui/track/highways/" $highway ".png"}}}
      {if {|| {$user get_track_type} kTrackGuitar kTrackRealGuitar} {watermark_guitar.tex set_bitmap {sprint "ui/track/highways/" $highway ".png"}}}
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} {watermark_keys.tex set_bitmap {sprint "ui/track/highways/" $highway ".png"}}}
      
      {if {== {$user get_track_type} kTrackDrum} {watermark_drum.tex iterate_refs $ref {$ref set diffuse_tex watermark_drum.tex}}}
      {if {|| {$user get_track_type} kTrackBass kTrackRealBass} {watermark_bass.tex iterate_refs $ref {$ref set diffuse_tex watermark_bass.tex}}}
      {if {|| {$user get_track_type} kTrackGuitar kTrackRealGuitar} {watermark_guitar.tex iterate_refs $ref {$ref set diffuse_tex watermark_guitar.tex}}}
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} {watermark_keys.tex iterate_refs $ref {$ref set diffuse_tex watermark_keys.tex}}}
      
      {if {== {$user get_track_type} kTrackDrum} {watermark_drum.tex iterate_refs $ref {$ref set emissive_map watermark_drum.tex}}}
      {if {|| {$user get_track_type} kTrackBass kTrackRealBass} {watermark_bass.tex iterate_refs $ref {$ref set emissive_map watermark_bass.tex}}}
      {if {|| {$user get_track_type} kTrackGuitar kTrackRealGuitar} {watermark_guitar.tex iterate_refs $ref {$ref set emissive_map watermark_guitar.tex}}}
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} {watermark_keys.tex iterate_refs $ref {$ref set emissive_map watermark_keys.tex}}}
      
      {if {== {$user get_track_type} kTrackDrum} {watermark_drum.tex iterate_refs $ref {$ref set emissive_multiplier 0.8}}}
      {if {|| {$user get_track_type} kTrackBass kTrackRealBass} {watermark_bass.tex iterate_refs $ref {$ref set emissive_multiplier 0.8}}}
      {if {|| {$user get_track_type} kTrackGuitar kTrackRealGuitar} {watermark_guitar.tex iterate_refs $ref {$ref set emissive_multiplier 0.8}}}
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} {watermark_keys.tex iterate_refs $ref {$ref set emissive_multiplier 0.8}}}
   }
}

{if $highwaygtrcustomtexture
   {unless {== $highwaygtr none}
      {if {|| {$user get_track_type} kTrackGuitar kTrackRealGuitar} {watermark_guitar.tex set_bitmap {sprint "ui/track/highways/" $highwaygtr ".png"}}}
      
      {if {|| {$user get_track_type} kTrackGuitar kTrackRealGuitar} {watermark_guitar.tex iterate_refs $ref {$ref set diffuse_tex watermark_guitar.tex}}}
      
      {if {|| {$user get_track_type} kTrackGuitar kTrackRealGuitar} {watermark_guitar.tex iterate_refs $ref {$ref set emissive_map watermark_guitar.tex}}}
      
      {if {|| {$user get_track_type} kTrackGuitar kTrackRealGuitar} {watermark_guitar.tex iterate_refs $ref {$ref set emissive_multiplier 0.8}}}
   }
}

{if $highwaybasscustomtexture
   {unless {== $highwaybass none}
      {if {|| {$user get_track_type} kTrackBass kTrackRealBass} {watermark_bass.tex set_bitmap {sprint "ui/track/highways/" $highwaybass ".png"}}}
      
      {if {|| {$user get_track_type} kTrackBass kTrackRealBass} {watermark_bass.tex iterate_refs $ref {$ref set diffuse_tex watermark_bass.tex}}}
      
      {if {|| {$user get_track_type} kTrackBass kTrackRealBass} {watermark_bass.tex iterate_refs $ref {$ref set emissive_map watermark_bass.tex}}}
      
      {if {|| {$user get_track_type} kTrackBass kTrackRealBass} {watermark_bass.tex iterate_refs $ref {$ref set emissive_multiplier 0.8}}}
   }
}

{if $highwaydrumcustomtexture
   {unless {== $highwaydrum none}
      {if {== {$user get_track_type} kTrackDrum} {watermark_drum.tex set_bitmap {sprint "ui/track/highways/" $highwaydrum ".png"}}}
      
      {if {== {$user get_track_type} kTrackDrum} {watermark_drum.tex iterate_refs $ref {$ref set diffuse_tex watermark_drum.tex}}}
      
      {if {== {$user get_track_type} kTrackDrum} {watermark_drum.tex iterate_refs $ref {$ref set emissive_map watermark_drum.tex}}}

      {if {== {$user get_track_type} kTrackDrum} {watermark_drum.tex iterate_refs $ref {$ref set emissive_multiplier 0.8}}}
   }
}

{if $highwaykeyscustomtexture
   {unless {== $highwaykeys none}
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} {watermark_keys.tex set_bitmap {sprint "ui/track/highways/" $highwaykeys ".png"}}}
      
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} {watermark_keys.tex iterate_refs $ref {$ref set diffuse_tex watermark_keys.tex}}}
      
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} {watermark_keys.tex iterate_refs $ref {$ref set emissive_map watermark_keys.tex}}}
      
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} {watermark_keys.tex iterate_refs $ref {$ref set emissive_multiplier 0.8}}}
   }
}

{if $crowdmetercustomtexture
   {unless {== $crowdmeter none}
      {crowd_meter_frame.tex set_bitmap {sprint "ui/track/crowd_meter/crowd_meter_frame_" $crowdmeter ".png"}}
      {crowd_meter_lens.tex set_bitmap {sprint "ui/track/crowd_meter/crowd_meter_lens_" $crowdmeter ".png"}}
   }
}

{if $multiringcustomtexture
   {unless {== $multiring none}
      {fx_peak_stripes.tex set_bitmap {sprint "ui/track/multiplier_ring/fx_peak_stripes_" $multiring ".png"}}
      {multiplier_meter_glow.tex set_bitmap {sprint "ui/track/multiplier_ring/multiplier_meter_glow_" $multiring ".png"}}
      {multiplier_meter.tex set_bitmap {sprint "ui/track/multiplier_ring/multiplier_meter_" $multiring ".png"}}
      {streak_meter_bg.tex set_bitmap {sprint "ui/track/multiplier_ring/streak_meter_bg_" $multiring ".png"}}
      {streak_meter_bg_vox.tex set_bitmap {sprint "ui/track/multiplier_ring/streak_meter_bg_vox_" $multiring ".png"}}
      {streak_meter_lens.tex set_bitmap {sprint "ui/track/multiplier_ring/streak_meter_lens_" $multiring ".png"}}
   ;   {streak_meter_plate_fc.tex set_bitmap {sprint "ui/track/multiplier_ring/streak_meter_plate_fc_" $multiring ".png"}}
      {streak_meter_plate.tex set_bitmap {sprint "ui/track/multiplier_ring/streak_meter_plate_" $multiring ".png"}}
   }
}

{if $odbarcustomtexture
   {unless {== $odbar none}
      {fx_rising_sun.tex set_bitmap {sprint "ui/track/overdrive_bar/fx_rising_sun_" $odbar ".png"}}
      {overdrive_meter_background_fill.tex set_bitmap {sprint "ui/track/overdrive_bar/overdrive_meter_background_fill_" $odbar ".png"}}
      {overdrive_meter_glass.tex set_bitmap {sprint "ui/track/overdrive_bar/overdrive_meter_glass_" $odbar ".png"}}
      {player_meter_long_lens.tex set_bitmap {sprint "ui/track/overdrive_bar/player_meter_long_lens_" $odbar ".png"}}
      {player_meter_long.tex set_bitmap {sprint "ui/track/overdrive_bar/player_meter_long_" $odbar ".png"}}
   }
}

{if $railscustomtexture
   {unless {== $rails none}
      {smasher_plate_bracket.tex iterate_refs $ref {$ref set alpha_cut true}}
      {beat_marker.tex set_bitmap {sprint "ui/track/rails/beat_marker_" $rails ".png"}}
      {rails.tex set_bitmap {sprint "ui/track/rails/rails_" $rails ".png"}}
      {rails_keyboard.tex set_bitmap {sprint "ui/track/rails/rails_" $rails ".png"}}
      {rails_rg.tex set_bitmap {sprint "ui/track/rails/rails_" $rails ".png"}}
      {smasher_plate_bracket.tex set_bitmap {sprint "ui/track/rails/smasher_plate_bracket_" $rails ".png"}}
   }
}

{if $scorecustomtexture
   {unless {== $scoretex none}
      {score_meter_wipe.tex set_bitmap {sprint "ui/track/score/score_meter_wipe_" $scoretex ".png"}}
      {score_star_frame.tex set_bitmap {sprint "ui/track/score/score_star_frame_" $scoretex ".png"}}
      {score_star_gold.tex set_bitmap {sprint "ui/track/score/score_star_gold_" $scoretex ".png"}}
      {scoreboard_frame.tex set_bitmap {sprint "ui/track/score/scoreboard_frame_" $scoretex ".png"}}
      {scoreboard_lens.tex set_bitmap {sprint "ui/track/score/scoreboard_lens_" $scoretex ".png"}}
      {star_multiplier_meter_frame.tex set_bitmap {sprint "ui/track/score/star_multiplier_meter_frame_" $scoretex ".png"}}
      {star_multiplier_meter_lens.tex set_bitmap {sprint "ui/track/score/star_multiplier_meter_lens_" $scoretex ".png"}}
      {tour_icon.tex set_bitmap {sprint "ui/track/score/tour_icon_" $scoretex ".png"}}
   }
}

{if $flamescustomtexture
   {unless {== $flames none}
      {gem_cap.tex set_bitmap {sprint "ui/track/flames/gem_cap_" $flames ".png"}}
      {broken_glass01.tex set_bitmap {sprint "ui/track/flames/broken_glass01_" $flames ".png"}}
      {broken_glass01_neg.tex set_bitmap {sprint "ui/track/flames/broken_glass01_neg_" $flames ".png"}}
      {broken_glass02.tex set_bitmap {sprint "ui/track/flames/broken_glass02_" $flames ".png"}}
      {flare_gtr_inner.tex set_bitmap {sprint "ui/track/flames/flare_gtr_inner_" $flames ".png"}}
      {flare_gtr_outer.tex set_bitmap {sprint "ui/track/flames/flare_gtr_outer_" $flames ".png"}}
      {flare_gtr_style.tex set_bitmap {sprint "ui/track/flames/flare_gtr_style_" $flames ".png"}}
      {flare_inner.tex set_bitmap {sprint "ui/track/flames/flare_inner_" $flames ".png"}}
      {flare_outer.tex set_bitmap {sprint "ui/track/flames/flare_outer_" $flames ".png"}}
      {flare_style.tex set_bitmap {sprint "ui/track/flames/flare_style_" $flames ".png"}}
      {fx_smasher_smoke.tex set_bitmap {sprint "ui/track/flames/fx_smasher_smoke_" $flames ".png"}}
      {radial_shockwave.tex set_bitmap {sprint "ui/track/flames/radial_shockwave_" $flames ".png"}}
      {spark.tex set_bitmap {sprint "ui/track/flames/sparks_" $flames ".png"}}
      {sparks_radial.tex set_bitmap {sprint "ui/track/flames/sparks_radial_" $flames ".png"}}
      {sparks_vertical.tex set_bitmap {sprint "ui/track/flames/sparks_vertical_" $flames ".png"}}
   }
}

{if $smashercustomtexture
   {unless {== $smasher none}
      {gem_smashers_guitar_nomip.tex set_bitmap {sprint "ui/track/smashers/gem_smashers_guitar_" $smasher ".png"}}
      {gem_smashers_guitar.tex set_bitmap {sprint "ui/track/smashers/gem_smashers_guitar_" $smasher ".png"}}
      {gem_smashers_drum_nomip.tex set_bitmap {sprint "ui/track/smashers/gem_smashers_drum_" $smasher ".png"}}
      {gem_smashers_drum.tex set_bitmap {sprint "ui/track/smashers/gem_smashers_drum_" $smasher ".png"}}
      {square_smasher_bright_green.tex set_bitmap {sprint "ui/track/smashers/square_smasher_bright_green_" $smasher ".png"}}
      {square_smasher_bright_red.tex set_bitmap {sprint "ui/track/smashers/square_smasher_bright_red_" $smasher ".png"}}
      {square_smasher_bright_yellow.tex set_bitmap {sprint "ui/track/smashers/square_smasher_bright_yellow_" $smasher ".png"}}
      {square_smasher_bright_blue.tex set_bitmap {sprint "ui/track/smashers/square_smasher_bright_blue_" $smasher ".png"}}
      {square_smasher_bright_orange.tex set_bitmap {sprint "ui/track/smashers/square_smasher_bright_orange_" $smasher ".png"}}
   }
}

{if $gemcustomtexture
   {unless {== $gem none}
      {gem_cymbal_diffuse.tex set_bitmap {sprint "ui/track/gems/gem_cymbal_diffuse_" $gem ".png"}}
      {gem_cymbal_ems.tex set_bitmap {sprint "ui/track/gems/gem_cymbal_ems_" $gem ".png"}}
      {gem_mash_green_emmisive.tex set_bitmap {sprint "ui/track/gems/gem_mash_green_emmisive_" $gem ".png"}}
      {gem_mash_red_emmisive.tex set_bitmap {sprint "ui/track/gems/gem_mash_red_emmisive_" $gem ".png"}}
      {gem_mash_yellow_emmisive.tex set_bitmap {sprint "ui/track/gems/gem_mash_yellow_emmisive_" $gem ".png"}}
      {gem_mash_blue_emmisive.tex set_bitmap {sprint "ui/track/gems/gem_mash_blue_emmisive_" $gem ".png"}}
      {gem_mash_orange_emmisive.tex set_bitmap {sprint "ui/track/gems/gem_mash_orange_emmisive_" $gem ".png"}}
      {gliss_gems.tex set_bitmap {sprint "ui/track/gems/gliss_gems_" $gem ".png"}}
      {prism_gems.tex set_bitmap {sprint "ui/track/gems/prism_gems_" $gem ".png"}}
      {prism_gem_emissive.tex set_bitmap {sprint "ui/track/gems/prism_gem_emissive_" $gem ".png"}}
      {prism_gem_keyboard_style.tex set_bitmap {sprint "ui/track/gems/prism_gem_keyboard_style_" $gem ".png"}}
   }
}

{if $sustaincustomtexture
   {unless {== $sustain none}
      {gem_tails.tex set_bitmap {sprint "ui/track/sustains/gem_tails_" $sustain ".png"}}
   }
}
      
{if $voxarrowcustomtexture
   {unless {== $voxarrow none}
      {pitch_arrow_lead_c.tex set_bitmap {sprint "ui/track/voxarrow/arrow_lead_c_" $voxarrow ".png"}}
      {arrow_lead_outline.tex set_bitmap {sprint "ui/track/voxarrow/arrow_lead_outline_" $voxarrow ".png"}}
   }
}

{if $voxhwcustomtexture
   {unless {== $voxhw none}
      {talky_mask.tex set_bitmap {sprint "ui/track/voxhw/talky_mask_" $voxhw ".png"}}
      {vocals_bg_combined.tex set_bitmap {sprint "ui/track/voxhw/vocal_bg_combined_" $voxhw ".png"}}
      {vocal_bg_notonic.tex set_bitmap {sprint "ui/track/voxhw/vocal_bg_notonic_" $voxhw ".png"}}
   }
}

{if $keyboardcustomtexture
   {unless {== $keyboard none}
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} {track_lanes_keyboard.tex set_bitmap {sprint "ui/track/keyboards/track_lanes_keyboard_" $keyboard ".png"}}}
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} {track_lanes_keyboard_press.tex set_bitmap {sprint "ui/track/keyboards/track_lanes_keyboard_press_" $keyboard ".png"}}}
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} {gem_smasher_sharp_diffuse_nomip.tex set_bitmap {sprint "ui/track/keyboards/gem_smasher_sharp_diffuse_nomip_" $keyboard ".png"}}}
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} {gem_mash_prokeys_ems.tex set_bitmap {sprint "ui/track/keyboards/gem_mash_prokeys_ems_" $keyboard ".png"}}}
      {if {|| {$user get_track_type} kTrackKeys kTrackRealKeys} {gem_mash_prokeys.tex set_bitmap {sprint "ui/track/keyboards/gem_mash_prokeys_" $keyboard ".png"}}}
   }
}
{set $rb2uicustomtexture FALSE}
{set $rb4uicustomtexture FALSE}
{set $rb2trkcustomtexture FALSE}
{set $rb4trkcustomtexture FALSE}
{set $animatedhighwaycustomtexture FALSE}
{set $animatedgemscustomtexture FALSE}
{set $animatedsmasherscustomtexture FALSE}
{set $highwaycustomtexture FALSE}
{set $spotlightcustomtexture FALSE}
{set $emissivecustomtexture FALSE}
{set $keyboardcustomtexture FALSE}

{if {modifier_mgr is_modifier_active mod_chmode}
   {rails.tex set_bitmap ui/track/custom_track_textures/rails_drunk.png}
   {rails_keyboard.tex set_bitmap ui/track/custom_track_textures/rails_drunk.png}
   {rails_rg.tex set_bitmap ui/track/custom_track_textures/rails_drunk.png}
   {smasher_plate_bracket.tex set_bitmap ui/track/custom_track_textures/smasher_plate_bracket_drunk.png}}

{$this play_intro}
      {if
         {&&
            {exists gamemode}
            {gamemode get play_track_intro_sfx}}
         {$this play_seq track_beg.cue}
         #ifdef HX_XBOX
         {unless
         {||
            {gamemode in_mode pro_song_lessons_keyboard} {gamemode in_mode pro_song_lessons_real_guitar}
            {gamemode in_mode pro_song_lessons_real_bass} {gamemode in_mode drum_freestyle}
            {gamemode in_mode trainer} {gamemode in_mode trainer_drums} {gamemode in_mode trainer_pro_drums}
            {gamemode in_mode trainer_real_guitar} {gamemode in_mode trainer_pro_keyboard}
            {gamemode in_mode audition} {&& {gamemode in_mode practice} {> {gamecfg get practice_speed} 0}}
         }
            {beatmatch set_music_speed $speedmod}}
         #else
         {unless
         {||
            {gamemode in_mode pro_song_lessons_keyboard} {gamemode in_mode pro_song_lessons_real_guitar}
            {gamemode in_mode pro_song_lessons_real_bass} {gamemode in_mode drum_freestyle}
            {gamemode in_mode trainer} {gamemode in_mode trainer_drums} {gamemode in_mode trainer_pro_drums}
            {gamemode in_mode trainer_real_guitar} {gamemode in_mode trainer_pro_keyboard}
            {&& {gamemode in_mode practice} {> {gamecfg get practice_speed} 0}}
         }
            {beatmatch set_music_speed $speedmod}}
         #endif
         {if
            {&&
               {gamemode in_mode practice}
               {>
                  {gamecfg get practice_speed}
                  0}}
            {beatmatch set_music_speed $modifier}}}
))
{new
   TrackPanel
   coop_track_panel
   (file
      "track/trackpanel.milo")
   TRACK_PANEL_HANDLERS}
{func
   get_track_panel
   {gamemode get track_panel}}
{set
   $playback_file
   ""}
